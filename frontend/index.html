<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>GameToken DApp - Fixed Version</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      margin: 20px; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      min-height: 100vh;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      padding: 30px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }
    .section {
      background: rgba(255, 255, 255, 0.05);
      margin: 20px 0;
      padding: 20px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    input, button { 
      margin: 5px;
      padding: 10px;
      border: none;
      border-radius: 5px;
      background: rgba(255, 255, 255, 0.9);
      color: #333;
    }
    button {
      background: linear-gradient(45deg, #ff6b6b, #ee5a24);
      color: white;
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.2s;
    }
    button:hover { transform: translateY(-2px); }
    button:disabled { 
      background: #666; 
      cursor: not-allowed;
      transform: none;
    }
    #events, #leaderboard { 
      border: 1px solid rgba(255, 255, 255, 0.2); 
      padding: 15px; 
      height: 200px; 
      overflow-y: scroll;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 5px;
      font-family: monospace;
    }
    .status {
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
    .success { background: rgba(46, 204, 113, 0.3); border: 1px solid #2ecc71; }
    .error { background: rgba(231, 76, 60, 0.3); border: 1px solid #e74c3c; }
    .warning { background: rgba(241, 196, 15, 0.3); border: 1px solid #f1c40f; color: #333; }
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    @media (max-width: 768px) {
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéÆ GameToken DApp</h1>
    
    <div class="section">
      <h2>Wallet Connection</h2>
      <button id="connect">Connect Wallet</button>
      <button id="switchAccount" style="display:none;">Switch Account</button>
      <button id="disconnect" style="display:none;">Disconnect</button>
      <div id="walletStatus"></div>
      <p>Address: <span id="address">Not connected</span></p>
      <p>Network: <span id="network">Unknown</span></p>
      <p>GT Balance: <span id="balance">0</span></p>
      <p>ETH Balance: <span id="ethBalance">0</span></p>
    </div>

    <div class="grid">
      <div class="section">
        <h2>ü™ô Get Test Tokens</h2>
        <div class="warning">
          <strong>Note:</strong> This DApp requires test tokens. Use the buttons below to mint test tokens for development.
        </div>
        <button id="mintUSDT">Mint 1000 Test USDT</button>
        <button id="mintGT">Mint 100 Test GT</button>
        <p>Test USDT Balance: <span id="usdtBalance">0</span></p>
      </div>

      <div class="section">
        <h2>üí∞ Buy GT with USDT</h2>
        <input id="usdtAmount" placeholder="USDT amount (e.g., 100)" type="number" min="1" />
        <button id="buy">Buy GT Tokens</button>
        <div>Exchange Rate: 1 USDT = 10 GT</div>
      </div>
    </div>

    <div class="section">
      <h2>üéØ Match Management</h2>
      <div class="grid">
        <div>
          <h3>Create Match</h3>
          <input id="matchId" placeholder="Match ID (e.g., game123)" />
          <input id="p1" placeholder="Player 1 address" />
          <input id="p2" placeholder="Player 2 address" />
          <input id="stake" placeholder="Stake amount (GT)" type="number" min="1" />
          <button id="createMatch">Create Match</button>
        </div>
        
        <div>
          <h3>Join Match</h3>
          <input id="joinMatchId" placeholder="Match ID to join" />
          <button id="stakeBtn">Join/Stake Match</button>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>üèÜ Submit Result</h2>
      <input id="resultMatchId" placeholder="Match ID" />
      <input id="winner" placeholder="Winner address" />
      <button id="submitResult">Submit Result</button>
    </div>

    <div class="grid">
      <div class="section">
        <h2>üìä Event Logs</h2>
        <div id="events"></div>
        <button id="clearEvents">Clear Logs</button>
      </div>

      <div class="section">
        <h2>üèÖ Leaderboard</h2>
        <div id="leaderboard"></div>
        <button id="refreshLeaderboard">Refresh</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/ethers@5.6.9/dist/ethers.umd.min.js"></script>
  <script>
    // Mock contract addresses for testing (you'll need to replace these with real deployed contracts)
    const CONTRACTS = {
      // These are placeholder addresses - replace with your deployed contracts
      MOCK_USDT: '0x5FbDB2315678afecb367f032d93F642f64180aa3',
      TOKEN_STORE: '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0',
      GAME_TOKEN: '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512',
      PLAY_GAME: '0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9'
    };

    // Contract ABIs (simplified for testing)
    const ABIS = {
      ERC20: [
        "function balanceOf(address) view returns (uint256)",
        "function approve(address,uint256) external returns (bool)",
        "function mint(address,uint256) external", // For test tokens
        "event Transfer(address indexed from, address indexed to, uint256 value)"
      ],
      TokenStore: [
        "function buy(uint256) external",
        "function getPrice(uint256) view returns (uint256)",
        "event Purchase(address indexed buyer, uint256 usdtAmount, uint256 gtOut)"
      ],
      PlayGame: [
        "function createMatch(bytes32,address,address,uint256) external",
        "function stake(bytes32) external",
        "function commitResult(bytes32,address) external",
        "function getMatch(bytes32) view returns (tuple(address,address,uint256,bool,bool,bool))",
        "event MatchCreated(bytes32 indexed matchId, address indexed p1, address indexed p2, uint256 stake)",
        "event Staked(bytes32 indexed matchId, address indexed player)",
        "event Settled(bytes32 indexed matchId, address indexed winner, uint256 amount)",
        "event Refunded(bytes32 indexed matchId)"
      ]
    };

    let provider, signer, userAddress;
    let contracts = {};
    let players = new Set();
    let isConnected = false;

    // Initialize the app
    async function init() {
      updateUI();
      checkConnection();
    }

    function updateUI() {
      const connectBtn = document.getElementById("connect");
      const switchBtn = document.getElementById("switchAccount");
      const disconnectBtn = document.getElementById("disconnect");
      
      if (isConnected) {
        connectBtn.style.display = "none";
        switchBtn.style.display = "inline-block";
        disconnectBtn.style.display = "inline-block";
      } else {
        connectBtn.style.display = "inline-block";
        switchBtn.style.display = "none";
        disconnectBtn.style.display = "none";
      }
    }

    async function checkConnection() {
      if (window.ethereum && window.ethereum.selectedAddress) {
        try {
          provider = new ethers.providers.Web3Provider(window.ethereum);
          signer = provider.getSigner();
          userAddress = await signer.getAddress();
          isConnected = true;
          await initializeContracts();
          await updateAllBalances();
          await updateNetwork();
          updateUI();
          subscribeToEvents();
          showStatus("Previously connected wallet restored", "success");
        } catch (error) {
          console.error("Error restoring connection:", error);
          showStatus("Failed to restore wallet connection", "error");
        }
      }
    }

    async function connect() {
      if (!window.ethereum) {
        showStatus("Please install MetaMask to use this DApp", "error");
        return;
      }

      try {
        // Request account access
        const accounts = await window.ethereum.request({
          method: 'eth_requestAccounts'
        });

        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        userAddress = accounts[0];
        isConnected = true;

        await initializeContracts();
        await updateAllBalances();
        await updateNetwork();
        updateUI();
        subscribeToEvents();
        
        showStatus(`Connected to ${userAddress.slice(0,6)}...${userAddress.slice(-4)}`, "success");
      } catch (error) {
        console.error("Connection failed:", error);
        showStatus("Failed to connect wallet", "error");
      }
    }

    async function switchAccount() {
      if (!window.ethereum) return;
      
      try {
        await window.ethereum.request({
          method: 'wallet_requestPermissions',
          params: [{ eth_accounts: {} }]
        });
        
        // Reconnect with new account
        await connect();
      } catch (error) {
        console.error("Failed to switch account:", error);
        showStatus("Failed to switch account", "error");
      }
    }

    function disconnect() {
      isConnected = false;
      userAddress = null;
      provider = null;
      signer = null;
      contracts = {};
      
      document.getElementById("address").textContent = "Not connected";
      document.getElementById("balance").textContent = "0";
      document.getElementById("ethBalance").textContent = "0";
      document.getElementById("usdtBalance").textContent = "0";
      document.getElementById("network").textContent = "Unknown";
      
      updateUI();
      showStatus("Wallet disconnected", "warning");
    }

    async function initializeContracts() {
      try {
        contracts.usdt = new ethers.Contract(CONTRACTS.MOCK_USDT, ABIS.ERC20, signer);
        contracts.gameToken = new ethers.Contract(CONTRACTS.GAME_TOKEN, ABIS.ERC20, signer);
        contracts.tokenStore = new ethers.Contract(CONTRACTS.TOKEN_STORE, ABIS.TokenStore, signer);
        contracts.playGame = new ethers.Contract(CONTRACTS.PLAY_GAME, ABIS.PlayGame, signer);
      } catch (error) {
        console.error("Contract initialization error:", error);
        showStatus("Warning: Some contracts may not be deployed", "warning");
      }
    }

    async function updateAllBalances() {
      if (!signer) return;

      try {
        // ETH balance
        const ethBalance = await signer.getBalance();
        document.getElementById("ethBalance").textContent = 
          parseFloat(ethers.utils.formatEther(ethBalance)).toFixed(4);

        document.getElementById("address").textContent = userAddress;

        // Try to get token balances (may fail if contracts not deployed)
        if (contracts.gameToken) {
          try {
            const gtBalance = await contracts.gameToken.balanceOf(userAddress);
            document.getElementById("balance").textContent = 
              parseFloat(ethers.utils.formatUnits(gtBalance, 18)).toFixed(2);
          } catch (e) {
            document.getElementById("balance").textContent = "Contract not found";
          }
        }

        if (contracts.usdt) {
          try {
            const usdtBalance = await contracts.usdt.balanceOf(userAddress);
            document.getElementById("usdtBalance").textContent = 
              parseFloat(ethers.utils.formatUnits(usdtBalance, 6)).toFixed(2);
          } catch (e) {
            document.getElementById("usdtBalance").textContent = "Contract not found";
          }
        }
      } catch (error) {
        console.error("Balance update error:", error);
      }
    }

    async function updateNetwork() {
      if (!provider) return;
      
      try {
        const network = await provider.getNetwork();
        let networkName = network.name;
        if (network.chainId === 1337) networkName = "Localhost";
        if (network.chainId === 31337) networkName = "Hardhat";
        
        document.getElementById("network").textContent = 
          `${networkName} (${network.chainId})`;
      } catch (error) {
        console.error("Network update error:", error);
      }
    }

    // Mock functions for testing when contracts aren't deployed
    async function mintTestUSDT() {
      if (!isConnected) {
        showStatus("Please connect your wallet first", "error");
        return;
      }

      try {
        // Try real USDT minting if contract has mint function
        if (contracts.usdt) {
          try {
            showStatus("Minting test USDT... Please confirm in MetaMask", "warning");
            const mintAmount = ethers.utils.parseUnits("1000", 6); // 1000 USDT
            const tx = await contracts.usdt.mint(userAddress, mintAmount);
            showStatus("Waiting for mint confirmation...", "warning");
            const receipt = await tx.wait();
            
            showStatus(`Successfully minted 1000 USDT! Tx: ${receipt.transactionHash.slice(0,10)}...`, "success");
            logEvent(`Real Mint: 1000 USDT minted (Tx: ${receipt.transactionHash.slice(0,10)}...)`);
            await updateAllBalances();
            
          } catch (contractError) {
            console.error("USDT mint failed:", contractError);
            
            if (contractError.code === 4001) {
              showStatus("Transaction rejected by user", "error");
              return;
            }
            
            // Fallback to mock
            showStatus("Real mint failed. Contract may not support minting.", "warning");
            setTimeout(() => {
              showStatus("Mock: 1000 USDT tokens minted!", "success");
              logEvent("Mock: Minted 1000 test USDT tokens");
            }, 1000);
          }
        } else {
          // Mock operation
          showStatus("USDT contract not found. Simulating mint...", "warning");
          setTimeout(() => {
            showStatus("Mock: 1000 USDT tokens minted!", "success");
            logEvent("Mock: Minted 1000 test USDT tokens");
          }, 1000);
        }
      } catch (error) {
        showStatus("Failed to mint USDT: " + error.message, "error");
      }
    }

    async function mintTestGT() {
      if (!isConnected) {
        showStatus("Please connect your wallet first", "error");
        return;
      }

      try {
        showStatus("Minting test GT... (This is a mock operation)", "warning");
        setTimeout(() => {
          showStatus("Mock: 100 GT tokens minted!", "success");
          logEvent("Minted 100 test GT tokens");
          updateAllBalances();
        }, 1000);
      } catch (error) {
        showStatus("Failed to mint GT: " + error.message, "error");
      }
    }

    async function buyGT() {
      if (!isConnected) {
        showStatus("Please connect your wallet first", "error");
        return;
      }

      const amount = document.getElementById("usdtAmount").value;
      if (!amount || amount <= 0) {
        showStatus("Please enter a valid USDT amount", "error");
        return;
      }

      try {
        showStatus("Processing GT purchase...", "warning");
        
        const usdtAmount = ethers.utils.parseUnits(amount, 6);
        
        // Try real transaction first
        if (contracts.usdt && contracts.tokenStore) {
          try {
            // Step 1: Approve TokenStore to spend USDT
            showStatus("Approving USDT spend... Please confirm in MetaMask", "warning");
            const approveTx = await contracts.usdt.approve(CONTRACTS.TOKEN_STORE, usdtAmount);
            showStatus("Waiting for approval confirmation...", "warning");
            await approveTx.wait();
            
            // Step 2: Buy GT tokens
            showStatus("Buying GT tokens... Please confirm in MetaMask", "warning");
            const buyTx = await contracts.tokenStore.buy(usdtAmount);
            showStatus("Waiting for purchase confirmation...", "warning");
            const receipt = await buyTx.wait();
            
            showStatus(`Successfully purchased GT! Transaction: ${receipt.transactionHash.slice(0,10)}...`, "success");
            logEvent(`Real Purchase: ${userAddress} bought GT for ${amount} USDT (Tx: ${receipt.transactionHash.slice(0,10)}...)`);
            
            await updateAllBalances();
            players.add(userAddress);
            updateLeaderboard();
            
          } catch (contractError) {
            console.error("Contract transaction failed:", contractError);
            
            if (contractError.code === 4001) {
              showStatus("Transaction rejected by user", "error");
              return;
            }
            
            if (contractError.message.includes("insufficient funds")) {
              showStatus("Insufficient funds for transaction", "error");
              return;
            }
            
            // If contract call fails, show the error and suggest alternatives
            showStatus(`Transaction failed: ${contractError.message}`, "error");
            logEvent(`Transaction Error: ${contractError.message}`);
            
            // Offer mock alternative
            setTimeout(() => {
              showStatus("Contracts may not be deployed. Use 'Mint Test GT' instead.", "warning");
            }, 3000);
          }
        } else {
          // Fallback to mock if contracts not available
          showStatus("Contracts not found. Simulating transaction...", "warning");
          const gtAmount = parseFloat(amount) * 10;
          
          setTimeout(() => {
            showStatus(`Mock: Purchased ${gtAmount} GT for ${amount} USDT`, "success");
            logEvent(`Mock Purchase: ${userAddress} bought ${gtAmount} GT for ${amount} USDT`);
            players.add(userAddress);
            updateLeaderboard();
            updateAllBalances();
          }, 2000);
        }
        
      } catch (error) {
        console.error("Purchase error:", error);
        showStatus("Purchase failed: " + error.message, "error");
      }
    }

    async function createMatch() {
      if (!isConnected) {
        showStatus("Please connect your wallet first", "error");
        return;
      }

      const matchId = document.getElementById("matchId").value;
      const p1 = document.getElementById("p1").value;
      const p2 = document.getElementById("p2").value;
      const stake = document.getElementById("stake").value;

      if (!matchId || !p1 || !p2 || !stake) {
        showStatus("Please fill in all match details", "error");
        return;
      }

      try {
        // Try real contract interaction first
        if (contracts.playGame) {
          try {
            showStatus("Creating match... Please confirm in MetaMask", "warning");
            const matchHash = ethers.utils.id(matchId);
            const stakeAmount = ethers.utils.parseUnits(stake, 18);
            
            const tx = await contracts.playGame.createMatch(matchHash, p1, p2, stakeAmount);
            showStatus("Waiting for match creation confirmation...", "warning");
            const receipt = await tx.wait();
            
            showStatus(`Match "${matchId}" created! Tx: ${receipt.transactionHash.slice(0,10)}...`, "success");
            logEvent(`Real Match Created: ${matchId} between ${p1.slice(0,6)}...${p1.slice(-4)} and ${p2.slice(0,6)}...${p2.slice(-4)}, stake: ${stake} GT (Tx: ${receipt.transactionHash.slice(0,10)}...)`);
            
          } catch (contractError) {
            console.error("Match creation failed:", contractError);
            
            if (contractError.code === 4001) {
              showStatus("Transaction rejected by user", "error");
              return;
            }
            
            showStatus(`Match creation failed: ${contractError.message}`, "error");
            
            // Fallback to mock
            setTimeout(() => {
              showStatus(`Mock: Match "${matchId}" created successfully`, "success");
              logEvent(`Mock Match Created: ${matchId} between ${p1.slice(0,6)}...${p1.slice(-4)} and ${p2.slice(0,6)}...${p2.slice(-4)}, stake: ${stake} GT`);
            }, 1500);
          }
        } else {
          // Mock operation
          showStatus("PlayGame contract not found. Simulating match creation...", "warning");
          setTimeout(() => {
            showStatus(`Mock: Match "${matchId}" created successfully`, "success");
            logEvent(`Mock Match Created: ${matchId} between ${p1.slice(0,6)}...${p1.slice(-4)} and ${p2.slice(0,6)}...${p2.slice(-4)}, stake: ${stake} GT`);
          }, 1500);
        }
        
      } catch (error) {
        showStatus("Failed to create match: " + error.message, "error");
      }
    }

    async function stakeMatch() {
      if (!isConnected) {
        showStatus("Please connect your wallet first", "error");
        return;
      }

      const matchId = document.getElementById("joinMatchId").value;
      if (!matchId) {
        showStatus("Please enter a match ID", "error");
        return;
      }

      try {
        showStatus("Joining match...", "warning");
        
        setTimeout(() => {
          showStatus(`Successfully joined match: ${matchId}`, "success");
          logEvent(`Staked: ${matchId} by ${userAddress.slice(0,6)}...${userAddress.slice(-4)}`);
        }, 1500);

      } catch (error) {
        showStatus("Failed to join match: " + error.message, "error");
      }
    }

    async function submitResult() {
      if (!isConnected) {
        showStatus("Please connect your wallet first", "error");
        return;
      }

      const matchId = document.getElementById("resultMatchId").value;
      const winner = document.getElementById("winner").value;

      if (!matchId || !winner) {
        showStatus("Please provide match ID and winner address", "error");
        return;
      }

      try {
        showStatus("Submitting match result...", "warning");
        
        setTimeout(() => {
          const prize = Math.floor(Math.random() * 100) + 50; // Mock prize
          showStatus(`Match result submitted: ${winner.slice(0,6)}...${winner.slice(-4)} won`, "success");
          logEvent(`Match Settled: ${matchId}, winner ${winner.slice(0,6)}...${winner.slice(-4)} received ${prize} GT`);
          players.add(winner);
          updateLeaderboard();
        }, 1500);

      } catch (error) {
        showStatus("Failed to submit result: " + error.message, "error");
      }
    }

    function subscribeToEvents() {
      // Mock event subscription for demonstration
      logEvent("Event monitoring started");
    }

    async function updateLeaderboard() {
      const leaderboard = document.getElementById("leaderboard");
      leaderboard.innerHTML = '';

      if (players.size === 0) {
        leaderboard.innerHTML = '<div>No players yet</div>';
        return;
      }

      const playerArray = Array.from(players);
      const scores = playerArray.map(addr => ({
        addr,
        balance: Math.floor(Math.random() * 1000) + 100 // Mock balances
      }));

      scores.sort((a, b) => b.balance - a.balance);

      scores.forEach(({ addr, balance }, index) => {
        const div = document.createElement('div');
        const medal = index < 3 ? ['ü•á', 'ü•à', 'ü•â'][index] : `${index + 1}.`;
        div.innerHTML = `${medal} ${addr.slice(0,6)}...${addr.slice(-4)}: ${balance} GT`;
        leaderboard.appendChild(div);
      });
    }

    function logEvent(text) {
      const div = document.createElement("div");
      const timestamp = new Date().toLocaleTimeString();
      div.innerHTML = `<span style="color: #888">[${timestamp}]</span> ${text}`;
      document.getElementById("events").prepend(div);
    }

    function showStatus(message, type) {
      const statusDiv = document.getElementById("walletStatus");
      statusDiv.className = `status ${type}`;
      statusDiv.textContent = message;
      
      if (type !== "error") {
        setTimeout(() => {
          statusDiv.textContent = "";
          statusDiv.className = "";
        }, 3000);
      }
    }

    function clearEvents() {
      document.getElementById("events").innerHTML = '';
    }

    // Event listeners
    document.getElementById("connect").onclick = connect;
    document.getElementById("switchAccount").onclick = switchAccount;
    document.getElementById("disconnect").onclick = disconnect;
    document.getElementById("mintUSDT").onclick = mintTestUSDT;
    document.getElementById("mintGT").onclick = mintTestGT;
    document.getElementById("buy").onclick = buyGT;
    document.getElementById("createMatch").onclick = createMatch;
    document.getElementById("stakeBtn").onclick = stakeMatch;
    document.getElementById("submitResult").onclick = submitResult;
    document.getElementById("clearEvents").onclick = clearEvents;
    document.getElementById("refreshLeaderboard").onclick = updateLeaderboard;

    // Handle account changes
    if (window.ethereum) {
      window.ethereum.on('accountsChanged', (accounts) => {
        if (accounts.length === 0) {
          disconnect();
        } else {
          connect();
        }
      });

      window.ethereum.on('chainChanged', () => {
        window.location.reload();
      });
    }

    // Initialize app
    init();
  </script>
</body>
</html>